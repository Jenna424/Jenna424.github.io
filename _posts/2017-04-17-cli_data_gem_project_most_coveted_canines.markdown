---
layout: post
title:  "CLI DATA GEM PROJECT: most_coveted_canines"
date:   2017-04-16 21:20:32 -0400
---

  As an animal-lover and the proud owner of two rescue dogs, I decided to design an application that ranks the 50 most popular dog breeds in the United States and provides information about their key characteristics. After Westminster Dog Show 2017, the American Kennel Club (AKC) released a list of the most popular dog breeds in 2016. I retrieved data from the AKC ranking webpage, which is comprised of two main parts. The principal page contains the full ranking list of dogs, displayed by breed and popularity rank. Clicking on an individual dog's link directs the user to that particular dog's profile page. Anticipating that my project would contain a Dog class, I planned to scrape a dog instance's `@url` and `@breed` attributes from the main full ranking webpage and extract additional attributes, such as `@group`, `@personality`, `@rank`, `@year_recognized`, `@exercise`, `@grooming`, `@fun_fact` and `@appearance`, from each dog's profile page.
  Running the command `bundle gem most_coveted_canines` in Learn IDE terminal stubbed out the shell of my project structure, replete with bin/ and lib/ directories, specs and a README.md, among other files. I began programming from the place where the user would interact with my program, namely, my executable file in the bin/ directory, which I defined as bin/most-coveted-canines. After adding executable permissions to the file, coding the shebang line, and requiring an environment file that I quickly stubbed out in lib/most_coveted_canines.rb, I wrote the code I wish I had to encapsulate the logic for my program into one object: `MostCovetedCanines::CLI.new.call`. I anticipated that I would create a command line interface class, instantiate an instance of that class and then call the instance method `#call` on that instance to start my program. I drafted a plan for my interface in plain pseudocode, which served as a blueprint for the program I would build:
