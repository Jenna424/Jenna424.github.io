---
layout: post
title:  "CLI DATA GEM PROJECT: most_coveted_canines"
date:   2017-04-16 21:20:32 -0400
---

As an animal-lover and the proud owner of two rescue dogs, I decided to design an application that ranks the 50 most popular dog breeds in the United States and provides information about their key characteristics. After Westminster Dog Show 2017, the American Kennel Club (AKC) released a list of the most popular dog breeds in 2016. I retrieved data from the AKC ranking webpage, which is comprised of two main parts. The principal page contains the full ranking list of dogs, displayed by breed and popularity rank. Clicking on an individual dog's link directs the user to that particular dog's profile page. Anticipating that my project would contain a `Dog` class, I planned to scrape a dog instance's `@url` and `@breed` attributes from the main full ranking webpage and extract additional attributes, such as `@group`, `@personality`, `@rank`, `@year_recognized`, `@exercise`, `@grooming`, `@fun_fact` and `@appearance`, from each dog's profile page.
	
Running the command `bundle gem most_coveted_canines` in Learn IDE terminal stubbed out the shell of my project structure, replete with `bin/` and `lib/` directories, specs and a `README.md`, among other files. I began programming from the place where the user would interact with my program, namely, my executable file in the `bin/` directory, which I defined as `bin/most-coveted-canines`. After adding executable permissions to the file, coding the shebang line, and requiring an environment file that I quickly stubbed out in `lib/most_coveted_canines.rb`, I wrote the code I wish I had to encapsulate the logic for my program into one object: `MostCovetedCanines::CLI.new.call`. I anticipated that I would create a command line interface class, instantiate an instance of that class and then call the instance method `#call` on that instance to start my program. I drafted a plan for my interface in plain pseudocode, which served as a blueprint for the program I would build:
	
1. Welcome user/display program title
2. Prompt user to select a specific ranking tier from those listed below
3. List Ranking Tiers: 1-10, 11-20, 21-30, 31-40, 41-50
4. User enters ranking range 
5. Display dogs (by rank number and breed name) that are included in that particular ranking tier
6. Prompt user to enter the rank number of a specific dog
7. Display that dog’s data
8. Ask if user wants to view another dog breed. If yes, execute program again. If no, exit the program.

Once I had a good understanding of what my program should accomplish from the user's perspective, I laid out the general architecture of my program. My application requires collaboration between three classes, or models. I delegated the responsibility of scraping the AKC website to my `MostCovetedCanines::Scraper` class. I adhered to the single responsibility principle, which dictates that each method should execute one procedure, or serve one function. Within my `Scraper` class, I first defined a class method `#scrape_ranking_list`. This method returns an array of hashes, where each hash contains two key/value pairs for a dog instance's `@breed` and `@url` attributes. The return value of `#scrape_ranking_list` is therefore an array that contains 50 hash elements corresponding to 50 dog instances. The keys in each hash represent a single dog instance's `@breed` and `@url` properties, and each key points to its respective value scraped from the principal AKC web page. I designed this method with the full intention of instantiating an individual dog instance with a hash containing data for its breed and url. Which brings me to my `Dog` class…

Within my `Dog` class, I defined a class method `#create_canine_collection`, which returns an array of newly instantiated dog instances that each have exactly two attributes of `@breed` and `@url`. When designing my `Dog` class, I found it especially helpful to think of my code in terms of metaphors and narratives. When a "puppy" (i.e. newly instantiated dog instance) is "born," or instantiated, it is initialized with two "inherent" attributes of `@breed` and `@url`, as these are the sole attributes scraped from the AKC website's principal ranking page. I decided to instantiate a dog instance with its `@url` attribute assigned and immediately accessible, knowing that I would eventually need to use the value of this `@url` attribute to extract more properties from the dog's personal profile page.

Within the method body of `#create_canine_collection`, I first call `#scrape_ranking_list` on my `Scraper` class to retrieve the array of hashes that each contain key/value pairs for a dog's breed and url. Calling `#collect` on this array of hashes invokes the block on each hash element and returns an array of the resulting values. When I call `#collect` on the array of hashes, for each hash containing a dog instance's breed and url key/value pairs, I invoke the block `{|canine_hash| self.new(canine_hash)}`, thereby initializing a new dog instance with that hash. The `#initialize` hook is automatically triggered whenever `#new` is called on the `Dog` class to instantiate a new dog instance. Within the method body of `#initialize`, I iterate through the two key/value pairs in the dog instance's hash, and I use mass assignment to set the dog instance's `@breed` and `@url` attributes. I call `#send` on that new dog instance to send it a method call as a string. The name of each hash key becomes the name of an instance setter method. I interpolate the name of each key (breed and url) to call the `#breed=()` and `#url=()` instance setter methods on the dog instance, setting its `@breed` and `@url` attributes equal to the corresponding hash values. When executing my program, the `#create_canine_collection` method is called on my `Dog` class within the `#make_puppies` instance method called on an instance of my `CLI` class. `#make_puppies` is the first method executed by my procedural `#call` instance method. Therefore, the first task completed when I run my program is to create an array of new dog instances that each have two properties of `@breed` and `@url`.

The next "storyline" in my coding "narrative" is to make my "puppy" dog instances "mature" into "adult" dogs that have all of their attributes set, rather than just `@breed` and `@url`. I knew I could access my array of newly-instantiated dog instances by calling `#create_canine_collection` on my `Dog` class. I wanted to be able to iterate through that array of "newborn" dog instances and give each dog instance several additional attributes. To do so, my `Dog` class needed to collaborate with my `Scraper` class once again. Accordingly, I defined a class method on my `Scraper` class called `#scrape_puppy_profile(puppy_url)` to extract data from an individual dog's profile page. Within the body of this method, I call the `#open` method with an argument of an individual dog's profile url (represented by the variable `puppy_url`). The return value of `#open(puppy_url)` is the HTML content of a particular dog's profile page found at the web address specified in the argument. The `Nokogiri::HTML` method converts this web content into a giant nested node HTML string, and I saved this node set to the variable `puppy_profile`. I set another variable, `puppy_properties`, equal to an empty hash, and I populated this hash with key/value pairs. The hash keys represent a dog instance's `@group`, `@personality`, `@year_recognized,` `@rank`, `@grooming`, `@exercise`, `@fun_fact` and `@appearance` attributes. The values corresponding to these key attributes were scraped, using Nokogiri, from the `puppy_profile` Nokogiri object that represents a dog's profile page. The return value of `#scrape_puppy_profile(puppy_url)` is a hash containing key/value pairs with data for the additional attributes I wish to assign a dog instance.

To add additional attributes to *all* of my dog instances, I defined a class method on my `Dog` class called `#assign_additional_attributes`, which relies on `#scrape_puppy_profile(puppy_url)`. Within the body of `#assign_additional_attributes`, I call `#create_canine_collection` on the `Dog` class and save the return value (i.e. the array of dog instances that only have `@breed` and `@url` attributes) to the variable `puppies_born`. I iterate through the `puppies_born` array, and for each "puppy" dog instance, I call the `#url` instance getter method on that dog instance to retrieve the value of its `@url` attribute. The `@url` attribute value of each dog instance is then passed in as the argument of the `#scrape_puppy_profile(puppy_url)` class method called on my `Scraper` class. I consequently obtain a `puppy_properties` hash for each of my dog instances, in which hash keys are the names of the additional attributes I wish to set and hash values are scraped data. For each dog instance, I iterate through the key/value pairs of its `puppy_properties` hash, and I use metaprogramming and mass assignment to assign the additional attributes to the dog instance. The name of each hash key becomes the name of an instance setter method using string interpolation: `"#{key}="`. This instance setter method is called on the dog instance to set its additional attributes equal to the corresponding hash values. For example, the `puppy_properties` hash corresponding to the dog instance with `@breed` attribute of "Retrievers (Labrador)" contains the key/value pairs of `{:group => "Sporting Group", :rank => "1"}`, among other key/value pairs. I call `#send` on the dog instance to set its `@group` and `@rank` attributes. The first argument passed into `#send` is the name of the method I am calling as a string. I therefore interpolate the "group" and "rank" key names and append an equals sign to create the instance setter methods `#group=()` and `#rank=()`, which are then called on the labrador dog instance. The values of `@group` and `@rank` are the corresponding hash values of "Sporting Group" and "1", respectively. These hash values are the second argument passed into the `#send` method. Once the iteration through the `puppy_properties` hash is complete and all of the dog instance's attributes have been set, I am ready to store that "full-grown", "mature" dog instance in the `@@all` array of all dog instances. I call the `#save` instance method on each dog instance, which pushes that dog instance into the `@@all` array using the shovel operator. I call the `#assign_additional_attributes` class method on my `Dog` class within the `#add_puppy_properties` instance method called on an instance of my `CLI` class to encapsulate this logic. The `#add_puppy_properties` method, in turn, becomes the second method executed within the body of my procedural `#call` method.

The `#unleash_dogs` instance method, which is the last method invoked by `#call`, initiates the main program loop. I first prompt the user to enter one of five ranges that each consists of 10 dog breeds ranked sequentially from most to least popular. I obtain the user's input as a string, remove any whitespace, convert the string to an integer, and then store this integer input in the variable `range_starts_at`, for later use in my conditional statement. I learned that calling the `#to_i` method on a string range returns the first number in that range as an integer. For example, given the following valid ranges, `"1-10".to_i` returns 1, `"11-20".to_i` returns 11, `"21-30".to_i` returns 21, `"31-40".to_i` returns 31 and `"41-50".to_i` returns 41. The user's input is *invalid* if the `range_starts_at` variable does *not* equal 1, 11, 21, 31 or 41. Consequently, the program will print out an error message and once again call `#unleash_dogs`.

However, if the user *has* typed in a valid range, meaning that the `range_starts_at` variable *does* equal 1, 11, 21, 31 or 41, a series of three methods will be executed. The first method invoked is `#reveal_range(first_in_range)`. This method takes in `range_starts_at` as an argument, which is the first integer in the range. The first step of `#reveal_range(first_in_range)` is to print which dog breeds the user will view, from the lowest rank number to the highest rank number in a specific ranking tier. Each range contains ten consecutive rank numbers, so I interpolate the value of `range_starts_at` (the lower limit of the range) and `range_starts_at+9` (the upper limit of the range) into the following string: `"Dogs Ranked from Numbers #{first_in_range} through #{first_in_range+9}"`. 

In order to display the dogs in a specific ranking tier by rank and breed, I use each dog instance's rank number to obtain its index position in the `Dog` class' `@@all` array. The array index at which a particular dog instance is found is always *one less* than its rank number. For example, dog instances with rank numbers 1 through 10 are located at array indices 0 through 9. In the method body of `#reveal_range(range_starts_at)`, I call the `#all` class reader on my `Dog` class to return the `@@all` array of all dog instances. I then use bracket notation to collect dog instances within a specific range of indices, thereby returning an array of dog instances in a certain ranking tier. For example, if the user wants to view dogs ranked from numbers 41-50, the corresponding array indices are 40-49. Since `range_starts_at` equals 41 and the first dog instance I retrieve from `@@all` is located at array index 40, I refer to index 40 as `range_starts_at-1`. The last dog instance I target is located at index 49, so I must add 8 to `range_starts_at`. I store the array returned by `MostCovetedCanines::Dog.all[range_starts_at-1..range_starts_at+8]` in the variable `dogs_requested`. Finally, I iterate through the `dogs_requested` array by calling `#each.with_index(range_starts_at)`, passing in the `range_starts_at` argument to offset the starting index to the lowest number (i.e. whichever number is first) in the ranking tier the user selected. For each dog instance included in the ranking tier, I use string interpolation and print out the dog's rank followed by its breed. I obtain each dog's breed by calling the `#breed` instance getter method on each dog instance, which returns its `@breed` attribute.

After the dogs in a particular ranking tier are listed by calling `#reveal_range(range_starts_at)`, the method `#demand_dog(first_in_range)` allows a user to learn more information about a dog breed of their choice. The user is first prompted to enter the rank of a dog breed. The input obtained is a string number, such as "1" or "50", which is then stored in the `input` variable. First I must check if the string `input` a user has entered corresponds to any dog instance's `@rank` attribute. To determine whether a dog instance *does* exist with its `@rank` attribute value equal to the `input` a user entered, I defined a new method on my `Dog` class. The `#demand_dog(first_in_range)` `CLI` instance method relies on the class finder `#find_by_rank(rank)` called on my `Dog` class. The user's string rank `input` is passed into the method as the `rank` argument. Within the method body of `#find_by_rank(rank)`, I use `#detect` to iterate through the `@@all` array of all dog instances and find the first dog instance element that makes the block evaluate to true. Within the block `{|dog| dog.rank == rank}`, I call the instance getter method `#rank` on a dog instance to retrieve its `@rank` attribute. The method returns the first dog instance whose `@rank` attribute is equal to the rank string `input` passed into the method as an argument. However, if *no* dog instance makes the block evaluate to `true`, `#detect` and, consequently, `#find_by_rank(input)` return `nil`. Since a dog instance with that `@rank` attribute value does *not* exist in the `@@all` array of dog instances, an error message is printed out notifying the user that their input is invalid and `#demand_dog(first_in_range)` is called again.

My first `if` statement clause of `#demand_dog(first_in_range)` will evaluate to `true` if a dog instance with the specified `@rank` attribute *does* exist in the `@@all` array (i.e. the `if` statement does *not* evaluate to `nil`). Consequently, the code beneath is executed, which consists of more embedded conditional logic. I first check to see if that string rank `input`, converted to an integer, is included in the range of numbers that comprise the ranking tier requested. As previously explained, `range_starts_at` and `range_starts_at+9` are the integers that delimit a single ranking tier. If the string rank `input`, converted to an integer, is between `range_starts_at` and `range_starts_at+9`, inclusive, I will immediately display the dog instance's data by calling the `#showcase_dog(input)` method described below. However, if the string rank `input`, converted to an integer, is *greater than* the maximum number in the ranking tier, `range_starts_at+9`, I will notify the user that the dog breed is actually *less popular* and therefore did not make the cut for the ranking tier requested. For dogs ranked 1-50, the *smaller* the rank number, the *more* popular the dog. Although the dog breed is less popular than those in the ranking tier requested, I display the dog's data by calling `#showcase_dog(input)` since it is still one of the 50 most popular dog breeds. The `else` clause of the embedded conditional statement encapsulates the following logic: if the string rank `input`, converted to an integer, is *less than* the minimum number in the ranking tier, `range_starts_at`, I will notify the user that the dog breed is actually *more* popular before calling `#showcase_dog(input)` to display the dog breed's data.

The aforementioned #showcase_dog(rank) CLI instance method features a specific dog breed by printing out information about its attributes. This method accepts a dog’s rank as a string and calls the class finder #find_by_rank(rank) on the Dog class with that string input as an argument. The variable the_dog stores the specific dog instance returned by #find_by_rank(input). For each attribute of the dog instance, I print out a string composed of two parts. The first part of the string labels the name of the attribute. For example, I create the string “Personality:” to label the @personality attribute. In order to create visual separation between the attribute name and the value of that attribute, I make the text of the attribute name yellow by calling #colorize on the “Personality:” string with a symbol argument of the color :yellow. The value of each attribute, found previously by scraping data from the AKC website, is returned by calling its corresponding instance reader method on the_dog instance. For example, the value of the_dog instance’s @personality property is stored in its @personality instance variable. Calling the #personality instance getter method on the_dog instance returns @personality. I then code the second part of the string, which consists of a single space followed by the interpolated value of #{the_dog.personality}. I concatenate the two parts of the string by using the shovel operator. 

Displaying the @appearance attribute of the_dog instance was slightly trickier. The value of @appearance, which is essentially a giant string, is text extracted from a <p> element on an individual dog’s profile page. I used a here doc and called 
#gsub(/^\s*|$\s*/, ""). I removed superfluous whitespace with a Regular Expressions argument, replacing 0 or more whitespace characters at either the start or end of a line with an empty string. After printing out all of the attributes of a particular dog breed, I created a visual separation between the dog’s data and the rest of my program logic by printing a line of green asterisks followed by a vertical space.

The final instance method defined in my CLI class is #pick_new_puppy. This method asks if the user wants to learn about another dog breed. The user’s input is obtained and stored in the input variable for later use in the method’s conditional logic. As seen in the conditional statement, entering “yes” will run the program again by calling #unleash_dogs, whereas entering “no” will output a goodbye message and exit the program. If the user types in anything other than “yes” or “no”, the input is invalid. Consequently, an error message is printed out in red text and #pick_new_puppy is called again until valid input is received.
