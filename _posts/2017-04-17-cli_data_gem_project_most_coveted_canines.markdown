---
layout: post
title:  "CLI DATA GEM PROJECT: most_coveted_canines"
date:   2017-04-16 21:20:32 -0400
---

As an animal-lover and the proud owner of two rescue dogs, I decided to design an application that ranks the 50 most popular dog breeds in the United States and provides information about their key characteristics. After Westminster Dog Show 2017, the American Kennel Club (AKC) released a list of the most popular dog breeds in 2016. I retrieved data from the AKC ranking webpage, which is comprised of two main parts. The principal page contains the full ranking list of dogs, displayed by breed and popularity rank. Clicking on an individual dog's link directs the user to that particular dog's profile page. Anticipating that my project would contain a Dog class, I planned to scrape a dog instance's `@url` and `@breed` attributes from the main full ranking webpage and extract additional attributes, such as `@group`, `@personality`, `@rank`, `@year_recognized`, `@exercise`, `@grooming`, `@fun_fact` and `@appearance`, from each dog's profile page.
	
Running the command `bundle gem most_coveted_canines` in Learn IDE terminal stubbed out the shell of my project structure, replete with bin/ and lib/ directories, specs and a README.md, among other files. I began programming from the place where the user would interact with my program, namely, my executable file in the bin/ directory, which I defined as bin/most-coveted-canines. After adding executable permissions to the file, coding the shebang line, and requiring an environment file that I quickly stubbed out in lib/most_coveted_canines.rb, I wrote the code I wish I had to encapsulate the logic for my program into one object: `MostCovetedCanines::CLI.new.call`. I anticipated that I would create a command line interface class, instantiate an instance of that class and then call the instance method `#call` on that instance to start my program. I drafted a plan for my interface in plain pseudocode, which served as a blueprint for the program I would build:
	
1. Welcome user/display program title
2. Prompt user to select a specific ranking tier from those listed below
3. List Ranking Tiers: 1-10, 11-20, 21-30, 31-40, 41-50
4. User enters ranking range 
5. Display dogs (by rank number and breed name) that are included in that particular ranking tier
6. Prompt user to enter the rank number of a specific dog
7. Display that dog’s data
8. Ask if user wants to view another dog breed. If yes, execute program again. If no, exit the program.


Once I had a good understanding of what my program should accomplish from the user’s perspective, I laid out the general architecture of my program. My application requires collaboration between three classes, or models. I delegated the responsibility of scraping the AKC website to my MostCovetedCanines::Scraper class. I adhered to the single responsibility principle, which dictates that each method should execute one procedure, or serve one function. Within my Scraper class, I first defined a class method #scrape_ranking_list. This method returns an array of hashes, where each hash contains two key/value pairs for a dog instance's @breed and @url attributes. The return value of #scrape_ranking_list is therefore an array that contains 50 hash elements corresponding to 50 dog instances. The keys in each hash represent a single dog instance’s @breed and @url properties, and each key points to its respective value scraped from the principal AKC web page. I designed this method with the full intention of instantiating an individual dog instance with a hash containing data for its breed and url. Which brings me to my Dog class…

Within my Dog class, I defined a class method #create_canine_collection, which returns an array of newly instantiated dog instances that each have exactly two attributes of @breed and @url. When designing my Dog class, I found it especially helpful to think of my code in terms of metaphors and narratives. When a “puppy” (i.e. newly instantiated dog instance) is “born,” or instantiated, it is initialized with two “inherent” attributes of breed and url, as these are the sole attributes scraped from the AKC website’s principal ranking page. I decided to instantiate a dog instance with its @url attribute assigned and immediately accessible, knowing that I would eventually need to use the value of this @url attribute to extract more properties from the dog’s personal profile page.

Within the method body of #create_canine_collection, I first call #scrape_ranking_list on my Scraper class to retrieve the array of hashes that each contain key/value pairs for a dog’s breed and url. Calling #collect on this array of hashes invokes the block on each hash element and returns an array of the resulting values. When I call #collect on the array of hashes, for each hash containing a dog instance’s breed and url key/value pairs, I invoke the block `{|canine_hash| self.new(canine_hash)}`, thereby initializing a new dog instance with that hash. The #initialize hook is automatically triggered whenever #new is called on the Dog class to instantiate a new dog instance. Within the method body of #initialize, I iterate through the two key/value pairs in the dog instance’s hash, and I use mass assignment to set the dog instance’s @breed and @url attributes. I call #send on that new dog instance to send it a method call as a string. The name of each hash key becomes the name of an instance setter method. I interpolate the name of each key—breed and url—to call the #breed=() and #url=() instance setter methods on the dog instance, setting its @breed and @url attributes equal to the corresponding hash values. When executing my program, the #create_canine_collection method is called on my Dog class within the #make_puppies instance method called on an instance of my CLI class. #make_puppies is the first method executed by my procedural #call CLI instance method. Therefore, the first task completed when I run my program is to create an array of new dog instances that each have two properties of @breed and @url.
	

