---
layout: post
title:      "Programming a Spanish Version of Boggle in React"
date:       2019-05-02 12:10:03 -0400
permalink:  programming_a_spanish_version_of_boggle_in_react
---


To gain more practice with unidirectional data flow and event handling in React, I created a Spanish version of Boggle that employs a click-and-drag-to-select technique for choosing adjacent lettered cubes during word formation. In my application, I first defined `Board` (which represents the 4x4 Boggle board grid) as a container class component, so that could create a  local state that initializes a `dragging` property set equal to `false`, by default. In addition to the `dragging` property, the initial state also contains key/value pairs for `chosenCubes` (the array of cube objects whose letters comprise the word being formed, in which each cube object has key/value pairs for its row coordinates, column coordinates and the letter that the cube landed on), and `palabraCreada` (the word currently being created, initially set equal to an empty string). When the user first depresses a button that represents a cube on the gameboard, (without releasing the initial click), the `dragging` key in `Board`'s local state must be set equal to `true`, so that the user can click the 'Shift' or 'Ctrl' key while dragging the computer mouse over contiguous cubes to select their corresponding letters for inclusion in the word. 

In React, data is passed from  a parent component to a child component via props, but a child component can cause state changes that result in the re-render of the parent component by invoking callback functions that were passed from the parent to the child as props. Keeping this in mind, I defined a callback function called `handleButtonDepressed` that is passed as a prop from parent `Board` component down to each child `Cube` component rendered in the `.map()` iteration in `Board`'s `render` method: `handleButtonDepressed={cubeObject => this.handleButtonDepressed(cubeObject)}`. This method accepts the cube object currently being iterated over as its argument. When invoked upon clicking a cube on the Boggle board,  it immediately returns false if the game has not yet begun, (since I do not want to capture clicks if the timer has not started yet), but if the game has already started, it asynchronously updates state by calling `.setState()` function to set `dragging` key to `true`. 

Each `Cube` component renders a `<button>` that represents a cube, or boggle dice, on the game board. Each `<button>` has an `onMouseDown` event attribute and, when the button is depressed but not released, the event handler callback function, `handleOnMouseDown`, is triggered: `<button onMouseDown={this.handleOnMouseDown}`. I defined this callback method in Cube class component. Within this method, I call the `handleOnButtonDepressed` callback function that the child `Cube` component received as a prop from its parent `Board` component: `handleOnMouseDown = event => { this.props.handleButtonDepressed(this.props.cube) }` Therefore, each Cube component has the ability to tell its parent Board component that it was the first cube depressed, so the dragging property should be updated to true in Board's local state, the cube that was clicked should be added to the chosenCubes array, and its corresponding letter should be the first letter in the palabraCreada string.


I used a similar technique for handling the mouse drag over subsequent cubes, as well as final word submission. In parent `Board` component, I defined a callback function called `handleDragOverCube`, that is passed as a prop to each child `Cube` component rendered in the `.map()` iteration. This function checks if the cube is selectable (i.e. it must be adjacent to the letter cube that was previously appended to the word).  If the user dragged the mouse over a cube that was just added to the word, this indicates that the user wants to remove the letter that was just added. To implement this "backspace" feature, I call `.slice()` to maintain immutability when removing the last cube object element from the copy of the `chosenCubes` array, as well as the last letter from the copy of `palabraCreada` string. Otherwise, the cube being dragged over represents a new letter that the user wants to add to the word. I use the spread operator to copy over all existing cube object elements into a new array, and I then push the cube object that the mouse just dragged over onto the end of the array. I also call `.concat()` on the palabraCreada, passing in the `landedLetter` of the cube dragged over. The`<button>` rendered by each `Cube` component has an `onMouseOver` event attribute, and when the mouse is dragged over the cube, `handleOnMouseOver` event handler callback function is invoked. In this function, which is defined in`Cube` component, I check if the shift or ctrl key is currently being held down, and if so, I call the `handleDragOverCube` callback function passed as a prop from `Board` component to `Cube` component: 
  `if (event.shiftKey || event.ctrlKey) { this.props.handleDragOverCube(this.props.cube)  }`.
	
Finally, in `Board` component, I defined `enviarPalabra` callback function, which handles word submission. If `dragging` is currently true (i.e. dragging is enabled) and `palabraCreada` (the word I'm trying to submit) is at least three characters long and is a unique word played, then I update state accordingly: the submitted word and its corresponding point value are added as a key/value pair to `palabrasFormadas` object in `Board`'s local state, `chosenCubes` and `palabraCreada` are set to an empty array and an empty string, respectively, and `dragging` is set equal to `false` again. The `<button>` rendered by each `Cube` component has an `onMouseUp` event attribute that calls the `handleOnMouseUp` callback function when the initial click is released. As long as the game is in progress and dragging is enabled, the `enviarPalabra` callback function that was passed as a prop from parent `Board` component to child `Cube` component is called to submit the word (if valid) and to disable dragging.


