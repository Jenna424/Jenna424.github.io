---
layout: post
title:      "Programming a Spanish Version of Boggle in React"
date:       2019-05-02 16:10:02 +0000
permalink:  programming_a_spanish_version_of_boggle_in_react
---


To gain more practice with unidirectional data flow and event handling in React, I created a Spanish version of Boggle that employs a click-and-drag-to-select technique for choosing adjacent lettered cubes during word formation. In my application, I first defined `Board` (which represents the 4x4 Boggle board grid) as a container class component, so that could create a  local state that initializes a `dragging` property set equal to `false`, by default. In addition to the `dragging` property, the initial state also contains key/value pairs for `chosenCubes` (the array of cube objects that comprise the word being formed, in which each cube object has key/value pairs for its row coordinates, column coordinates and the letter that the cube landed on), and `palabraCreada` (the word currently being created, initially set equal to an empty string). When the user first depresses a button that represents a cube on the gameboard, (without releasing the initial click), the `dragging` key in `Board`'s local state must be set equal to `true`, so that the user can click the 'Shift' or 'Ctrl' key while dragging the computer mouse over contiguous cubes to select their corresponding letters for inclusion in the word. 

In React, data is passed from parent components to child components via props, but a child component can cause data changes that result in the re-render of the parent by invoking callback functions that were passed from the parent to the child as props. Keeping this in mind, I defined a callback function called `handleButtonDepressed` that is passed as a prop from parent `Board` component down to each child `Cube` component rendered in the `.map()` iteration in `Board`'s `render` method: `handleButtonDepressed={cubeObject => this.handleButtonDepressed(cubeObject)}`. This method accepts the cube object currently being iterated over as its argument. When invoked,  it immediately returns false if the game has not yet begun, since I do not want to capture clicks if the timer has not been started yet, but if the game has already started, it asynchronously updates state by calling `.setState()` function to set `dragging` key to `true`. 

Each `Cube` component renders a `<button>` that represents a cube, or boggle dice, on the game board. Each `<button>` has an `onMouseDown` event attribute and, when the button is depressed but not released, the event handler callback function, `handleOnMouseDown`, is triggered: `<button...onMouseDown={this.handleOnMouseDown}`. I defined this callback method in Cube class component. Within this method, I call the `handleOnButtonDepressed` callback function that the child `Cube` component received as a prop from its parent `Board` component: `handleOnMouseDown = event => { this.props.handleButtonDepressed(this.props.cube) }` Therefore, each Cube component has the ability to tell the parent component that it's been depressed, so the dragging property should be updated to true, the cube should be added to the chosenCubes array and its corresponding letter should be the first letter in the palabraCreada string.


