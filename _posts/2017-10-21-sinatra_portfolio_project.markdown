---
layout: post
title:      "Sinatra Portfolio Project"
date:       2017-10-21 12:43:27 +0000
permalink:  sinatra_portfolio_project
---


	For my portfolio project, I built an MVC Sinatra Application called Movement Mixer that allows users to design and manage custom, personalized workout routines. My domain model consists of four principal ActiveRecord classes, User, Routine, Movement and MovementRoutine, which are mapped to the corresponding database tables of users, routines, movements and movement_routines, respectively. A user instance has three required attributes: @name, @email and @password. A routine instance is assigned the attributes of @name, @training_type, @duration, @difficulty_level, @equipment and @user_id. The latter attribute corresponds to the user_id foreign key column in the routines table because a routine instance belongs to a single user instance. Accordingly, I added the belongs_to ActiveRecord macro in the Routine class and the has_many macro in the User class. A user instance has many routine instances because a user can create multiple personalized workout plans. A custom workout routine is tailored to the individual who created it, so a routine instance can only belong to one user instance. A movement instance is given the attributes @name, @instructions, @target_area, @reps, @sets, @modification,@challenge and @user_id. As in the case of a routine instance, a movement instance belongs to the user instance who created it; a user describes his/her unique technique of performing the exercise. Accordingly, I added the belongs_to macro to the Movement class and the has_many macro to the User class. Establishing a many-to-many relationship between movements and routines required the use of the movement_routines join table. A workout routine comprises several different exercise movements, so a routine instance ‘has many’ movement instances. Although a user can only modify the movements that belong to him/her, i.e., the movements that the user created, a single exercise movement can be used in multiple workout routines, so a movement instance ‘has many' routine instances in which it is performed. Consequently, I added has_many :movement_routines macro to both the Movement and Routine classes. A routine instance has_many :movements, through: :movement_routines, and a movement instance has_many :routines, through: :movement_routines. 
	When planning my domain model, I also anticipated that my classes would use similar methods to facilitate the creation of valid URLs that navigate to the show page of a single user, movement or routine instance. Since user, routine and movement instances all have @name attributes, I defined #generate_slug and .find_by_slugged_name(slugged_name) in Sluggable::InstanceMethods and Sluggable::ClassMethods nested modules, respectively, which I included and extended in my models to access these methods. Thus, I adhered to the DRY principle by eliminating repetitious patterns in my code.

Controllers
	In my config.ru file, I load my environment and mount my controllers. In my main controller, ApplicationController class, I enable sessions and set the session_secret. A user is logged into Movement Mixer app by pointing the :user_id key in the session hash to the@id attribute value of the particular user instance who’s trying to sign in: session[:user_id] = user.id. In my main controller, I define two helper methods, #current_user and #logged_in?, which add logic to my views. Within the method body of #current_user, if a user is logged in (meaning that session[:user_id] returns true because it’s set equal to the @id attribute value of the logged-in user instance), the user instance whose @id attribute value is equal to session[:user_id] is returned. If a logged-in user is found, the instance variable @current_user will be assigned to store this currently logged-in user instance. The #logged_in? method is the truthiness of calling #current_user, which returns the user instance logged in, a truthy value, if one is detected. Finally, I define the root route, get ‘/‘, in ApplicationController. The root route renders the index.erb view file to display the website homepage, which contains a welcome message and provides links to sign up or log in.
	My UsersController class, which inherits from the main ApplicationController, relies heavily on the concept of authentication to verify that the user is who they claim to be. The UsersController class encapsulates the logic for registering users, as well as the logic for logging them in and out of the application. The create action of UsersController consists of two routes: get ‘/signup’ and post ‘/signup’. The former route is an HTTP GET request to localhost:9393/signup, where a form is presented to create and register a new user. Using conditional logic in this controller action, I stipulate that the user registration form is only visible to users who are not already logged in; a logged-in user is unable to view the signup form and is instead redirected to localhost:9393/routines, where an index of all routines designed by all users is displayed. However, if a user is not already logged in, the create_user.erb view file is rendered, which contains the form to create a new user account. The create_user.erb view file contains an <h2> header with text that reads “User Registration,” a form with three fields corresponding to the required @name, @email and @password attributes of a user instance, and a submit button labelled “Register Now.” The second component of the create action, the post ‘/signup’ route, receives the POST request sent by the signup form upon submission; it receives the data submitted in the form to create a new user and processes it. In the line of code that reads @user = User.new(params), a user instance is instantiated with its @name, @email and @password attributes set via mass assignment, since the params hash contains the data, in the form of key/value pairs, that was submitted for these attributes: params = {“name” => “@name value”, “email” => “@email value”, “password” => “@password value”}. Due to the has_secure_password macro, as well as Active Record validations for @name and @email attributes, a user instance will only be successfully saved to the database if all fields for name, email and password are filled out, i.e., the values are not empty strings. If the user instance is successfully saved to the database by calling #save on it, i.e., if its row representation is inserted into the users table, the newly-minted user instance is logged in by setting the :user_id key of the session hash equal to its @id attribute value, which is retrieved by calling the #id getter method on the user instance. The newly-created and logged-in user is then redirected to localhost:9393/routines where the index of routines designed by all users is displayed. However, if the user left name, email or password form fields blank, (at least one empty string value is detected), a new user instance will not be saved to the database; the user is redirected to the webpage that displays the signup form to try registering again, and a flash message reminds the user that completion of all form fields is required to successfully register for the app.
 	When the user visits the page to log in to Movement Mixer, he/she is making a GET request, via the get “/login” route, to localhost:9393/login, where the login form is displayed. If a user who is already logged in tries to visit the login page, he/she is instead redirected to the index of all routines designed by all users. However, if the user is not already logged in, the login.erb view file is rendered to display the login form, which contains an <h2> header with text that reads “Log In,” a form containing two fields for the user to input their name and password, and a submit button that reads “Log In.” The post '/login' route receives the POST request sent by the login form upon submission;  it receives the data submitted in the login form and processes it. Within this post ‘/login’ controller action, ActiveRecord’s #find_by method is called on the User class to return the user instance whose @name attribute value equals params[:name], i.e., whatever the user entered in the name field of the login form. If a user instance with the specified @name attribute value is not found, #find_by returns nil, which is a falsey value. In the line of code user && user.authenticate(params[:password]), we call the #authenticate ActiveRecord method, provided by has_secure_password macro, on the user instance, passing in params[:password], i.e., whatever the user entered in the password field of the login form. If a user instance authenticates with that @password attribute value, meaning that the password is correct, the user instance is returned, which is a truthy value; otherwise, false is returned. Since the expression true && true returns true, if a user instance (a truthy value) with the specified @name attribute value exists, and if the user instance (a truthy value) authenticates with the @password attribute value, a user with a valid name and password combination has been found. Consequently, the user is logged in to Movement Mixer by setting the :user_id key of the session hash equal to the @id attribute value of the user instance, returned by calling the #id getter method on the user instance. The user is then redirected to localhost:9393/routines, the webpage that displays all routines designed by all users. However, if a user account with that particular name and password combination does not exist, the browser navigates to localhost:9393/login, where a flash message alerts the user that he/she inputted an invalid name and password combination, before prompting the user to try signing in again.
	The route get '/logout' is a GET request to localhost:9393/logout, and it contains the conditional logic for signing a user out of Movement Mixer app. If a logged-in user navigates to localhost:9393/logout, the user is logged out of the app by calling #clear on the session hash, at which point the user is redirected to the webpage where the login form is presented. However, if a user who is not logged in navigates to the logout page, they are promptly redirected to the root URL of the website, localhost:9393, which is the homepage containing links to register or log in.
	The route get '/users/:slug' is a GET request to the webpage that displays information about a specific user instance. The slugged version of the user instance’s @name attribute value replaces the :slug route variable. Within this controller action, the #find_by_slugged_name(slugged_name) method, defined in the extended Sluggable::ClassMethods module, is called on the User class. Within this method body, #generate_slug is called on the user instance to return the slugged version of the @name attribute value of the user instance, in which all letters are lowercase and all spaces are replaced with hyphens. The user instance is returned whose slugged @name attribute value equals params[:slug], i.e., whatever was entered into the URL to replace the :slug route variable. This user instance is stored in the @user instance variable to pass to the rendered view file, show_user.erb. 
	The show_user.erb view file displays a list of workout routines designed by a single user. I decided to give all users access to the profile page of a particular user, so that users can browse each other’s workout routines, learn about the different techniques used to perform similar exercise movements and gain inspiration for designing their own workout plans. At the top of the show_user.erb view file, the user is identified by its @name attribute value, which is retrieved by calling the #name getter on the @user instance and injecting this value into the <h3> header text using ERB substitution tags. Next, calling #routines on the @user instance returns the array of routine instances belonging to the @user instance. I iterate through this array of routine instances, and for each routine instance belonging to the user instance, I generate a list item, which contains a link to each routine instance’s show page. The clickable text of each routine’s show page link is the @name attribute value of the routine instance. I call the #name getter on the routine instance to retrieve its @name attribute value and inject this value between the opening and closing <a></a> tags using ERB substitution. I call #generate_slug on the routine instance to return the slugged version of its @name attribute value, which I inject into the string URL value of the href attribute of the <a> tag. The result is an unordered list of links to the webpages that display all of the user’s workout routines.

