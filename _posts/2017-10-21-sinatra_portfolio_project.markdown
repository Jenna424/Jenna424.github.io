---
layout: post
title:      "Movement Mixer Sinatra Portfolio Project"
date:       2017-10-21 08:43:28 -0400
permalink:  sinatra_portfolio_project
---

For my portfolio project, I built an MVC Sinatra Application called Movement Mixer that allows users to design and manage custom, personalized workout routines. My domain model consists of four principal ActiveRecord classes, `User`, `Routine`, `Movement` and `MovementRoutine`, which are mapped to the corresponding database tables of `users`, `routines`, `movements` and `movement_routines`, respectively. A user instance has three required attributes: `@name`, `@email` and `@password`. A routine instance is assigned the attributes of `@name`, `@training_type`, `@duration`, `@difficulty_level`, `@equipment` and `@user_id`. The latter attribute corresponds to the `user_id` foreign key column in the `routines` table because a routine instance belongs to a single user instance. Accordingly, I added the `belongs_to` ActiveRecord macro in the `Routine` class and the `has_many` macro in the `User` class. A user instance has many routine instances because a user can create multiple personalized workout plans. A custom workout routine is tailored to the individual who created it, so a routine instance can only belong to one user instance. A movement instance is given the attributes `@name`, `@instructions`, `@target_area`, `@reps`, `@sets`, `@modification`, `@challenge` and `@user_id`. As in the case of a routine instance, a movement instance belongs to the user instance who created it; a user describes his/her unique technique of performing the exercise. Accordingly, I added the `belongs_to` macro to the `Movement` class and the `has_many` macro to the `User` class. Establishing a many-to-many relationship between movements and routines required the use of the `movement_routines` join table. A workout routine comprises several different exercise movements, so a routine instance 'has many' movement instances. Although a user can only modify the movements that belong to him/her, i.e., the movements that the user created, a single exercise movement can be used in multiple workout routines, so a movement instance 'has many' routine instances in which it is performed. Consequently, I added `has_many :movement_routines` macro to both the `Movement` and `Routine` classes. A routine instance `has_many :movements, through: :movement_routines`, and a movement instance `has_many :routines, through: :movement_routines`.

When planning my domain model, I also anticipated that my classes would use similar methods to facilitate the creation of valid URLs that navigate to the show page of a single user, movement or routine instance. Since user, routine and movement instances all have `@name` attributes, I defined `#generate_slug` and `.find_by_slugged_name(slugged_name)` in `Sluggable::InstanceMethods` and `Sluggable::ClassMethods` nested modules, respectively, which I included and extended in my models to access these methods. Thus, I adhered to the DRY principle by eliminating repetitious patterns in my code.

In my config.ru file, I load my environment and mount my controllers. In my main controller, `ApplicationController` class, I enable sessions and set the `session_secret`. A user is logged into Movement Mixer app by pointing the `:user_id` key in the `session` hash to the `@id`attribute value of the particular user instance who's trying to sign in: `session[:user_id] = user.id`. In my main controller, I define two helper methods, `#current_user` and `#logged_in?`, which add logic to my views. Within the method body of `#current_user`, if a user is logged in (meaning that `session[:user_id]` returns true because it’s set equal to the `@id` attribute value of the logged-in user instance), the user instance whose `@id` attribute value is equal to `session[:user_id]` is returned. If a logged-in user is found, the instance variable `@current_user` will be assigned to store this currently logged-in user instance. The `#logged_in?` method is the truthiness of calling `#current_user`, which returns the user instance logged in, a truthy value, if one is detected. Finally, I define the root route, `get '/'`, in `ApplicationController`. The root route renders the index.erb view file to display the website homepage, which contains a welcome message and provides links to sign up or log in.

My `UsersController` class, which inherits from the main `ApplicationController`, relies heavily on the concept of authentication to verify that the user is who they claim to be. The `UsersController` class encapsulates the logic for registering users, as well as the logic for logging them in and out of the application. The create action of `UsersController` consists of two routes: `get '/signup'` and `post '/signup'`. The former route is an HTTP GET request to localhost:9393/signup, where a form is presented to create and register a new user. Using conditional logic in this controller action, I stipulate that the user registration form is only visible to users who are not already logged in; a logged-in user is unable to view the signup form and is instead redirected to localhost:9393/routines, where an index of all routines designed by all users is displayed. However, if a user is not already logged in, the create_user.erb view file is rendered, which contains the form to create a new user account. The create_user.erb view file contains an `<h2>` header with text that reads "User Registration," a form with three fields corresponding to the required `@name`, `@email` and `@password` attributes of a user instance, and a submit button labelled "Register Now." The second component of the create action, the `post '/signup'` route, receives the POST request sent by the signup form upon submission; it receives the data submitted in the form to create a new user and processes it. In the line of code that reads `@user = User.new(params)`, a user instance is instantiated with its `@name`, `@email` and `@password` attributes set via mass assignment, since the params hash contains the data, in the form of key/value pairs, that was submitted for these attributes: `params = {"name" => "@name value", "email" => "@email value", "password" => "@password value"}`. Due to the `has_secure_password macro`, as well as Active Record validations for `@name` and `@email` attributes, a user instance will only be successfully saved to the database if all fields for name, email and password are filled out, i.e., the values are not empty strings. If the user instance is successfully saved to the database by calling `#save` on it, i.e., if its row representation is inserted into the `users` table, the newly-minted user instance is logged in by setting the `:user_id` key of the session hash equal to its `@id` attribute value, which is retrieved by calling the `#id` getter method on the user instance. The newly-created and logged-in user is then redirected to localhost:9393/routines where the index of routines designed by all users is displayed. However, if the user left name, email or password form fields blank, (at least one empty string value is detected), a new user instance will not be saved to the database; the user is redirected to the webpage that displays the signup form to try registering again, and a flash message reminds the user that completion of all form fields is required to successfully register for the app.

When the user visits the page to log in to Movement Mixer, he/she is making a GET request, via the `get "/login"` route, to localhost:9393/login, where the login form is displayed. If a user who is already logged in tries to visit the login page, he/she is instead redirected to the index of all routines designed by all users. However, if the user is not already logged in, the login.erb view file is rendered to display the login form, which contains an `<h2>` header with text that reads "Log In," a form containing two fields for the user to input their name and password, and a submit button that reads "Log In." The `post '/login'` route receives the POST request sent by the login form upon submission;  it receives the data submitted in the login form and processes it. Within this `post '/login'` controller action, ActiveRecord's `#find_by` method is called on the `User` class to return the user instance whose `@name` attribute value equals `params[:name]`, i.e., whatever the user entered in the name field of the login form. If a user instance with the specified `@name` attribute value is not found, `#find_by` returns nil, which is a falsey value. In the line of code `user && user.authenticate(params[:password])`, we call the `#authenticate` ActiveRecord method, provided by `has_secure_password` macro, on the user instance, passing in `params[:password]`, i.e., whatever the user entered in the password field of the login form. If a user instance authenticates with that `@password` attribute value, meaning that the password is correct, the user instance is returned, which is a truthy value; otherwise, false is returned. Since the expression `true && true` returns `true`, if a user instance (a truthy value) with the specified `@name` attribute value exists, and if the user instance (a truthy value) authenticates with the `@password` attribute value, a user with a valid name and password combination has been found. Consequently, the user is logged in to Movement Mixer by setting the `:user_id` key of the `session` hash equal to the `@id` attribute value of the user instance, returned by calling the `#id` getter method on the user instance. The user is then redirected to localhost:9393/routines, the webpage that displays all routines designed by all users. However, if a user account with that particular name and password combination does not exist, the browser navigates to localhost:9393/login, where a flash message alerts the user that he/she inputted an invalid name and password combination, before prompting the user to try signing in again.

The route `get '/logout'` is a GET request to localhost:9393/logout, and it contains the conditional logic for signing a user out of Movement Mixer app. If a logged-in user navigates to localhost:9393/logout, the user is logged out of the app by calling `#clear` on the `session` hash, at which point the user is redirected to the webpage where the login form is presented. However, if a user who is not logged in navigates to the logout page, they are promptly redirected to the root URL of the website, localhost:9393, which is the homepage containing links to register or log in.

The route `get '/users/:slug'` is a GET request to the webpage that displays information about a specific user instance. The slugged version of the user instance's `@name` attribute value replaces the `:slug` route variable. Within this controller action, the `#find_by_slugged_name(slugged_name)` method, defined in the extended `Sluggable::ClassMethods` module, is called on the `User` class. Within this method body, `#generate_slug` is called on the user instance to return the slugged version of the `@name` attribute value of the user instance, in which all letters are lowercase and all spaces are replaced with hyphens. The user instance is returned whose slugged `@name` attribute value equals `params[:slug]`, i.e., whatever was entered into the URL to replace the `:slug` route variable. This user instance is stored in the `@user` instance variable to pass to the rendered view file, show_user.erb. 

The show_user.erb view file displays a list of workout routines designed by a single user. I decided to give all users access to the profile page of a particular user, so that users can browse each other's workout routines, learn about the different techniques used to perform similar exercise movements and gain inspiration for designing their own workout plans. At the top of the show_user.erb view file, the user is identified by its `@name` attribute value, which is retrieved by calling the `#name` getter on the `@user` instance and injecting this value into the `<h3>` header text using ERB substitution tags. Next, calling `#routines` on the `@user` instance returns the array of routine instances belonging to the `@user` instance. I iterate through this array of routine instances, and for each routine instance belonging to the user instance, I generate a list item, which contains a link to each routine instance's show page. The clickable text of each routine's show page link is the `@name` attribute value of the routine instance. I call the `#name` getter on the routine instance to retrieve its `@name` attribute value and inject this value between the opening and closing `<a></a>` tags using ERB substitution. I call `#generate_slug` on the routine instance to return the slugged version of its `@name` attribute value, which I inject into the string URL value of the `href` attribute of the `<a>` tag. The result is an unordered list of links to the webpages that display all of the user's workout routines.

An explanation of the logic contained in `RoutinesController` is representative of the way in which I programmed this class, as well as my `MovementsController` class, which follows similar design patterns. `RoutinesController` class inherits from my main `ApplicationController` class. The `get '/routines' route` is an HTTP GET request to localhost:9393/routines, the index page where all workout routines designed by all users are displayed. Using conditional logic, I stipulate that a user can only see the archive of all workout routines if that user is logged into Movement Mixer application. If the user is logged in, I call `#all` on the `Routine` class to return an array of all routine instances, which is stored in `@all_routines` instance variable to pass this data to the rendered view file, routines_index.erb. Within this file, I iterate through the array of all routine instances. For each routine instance, I generate a list item containing the link to that particular routine's show page, where the clickable text of each link is the `@name` attribute value of the specific routine instance. The result is an unordered list composed of links to all routine show pages. By contrast, a user who is not logged in is promptly redirected to the webpage that presents the login form, and a flash message alerts the user that they must log in to view the index of all workout routines.

**Create Action:**

The create action of my `RoutinesController` class is encapsulated in two routes: `get '/routines/new'` and `post '/routines'`. The former route is an HTTP GET request to localhost:9393/routines/new, where a form is presented to create a new workout routine if the user is logged in; otherwise, the user is redirected to the login page where they are given a friendly reminder to login via a flash message. The latter route receives the HTTP POST request sent by the form upon submission; this route receives the data submitted in the form and processes it to create the new workout. 

The nested form used to create a workout routine is found in the view file create_routine.erb. The logged-in user is first prompted to enter data into five form fields corresponding to the five required attributes of a routine instance (`@name`, `@training_type`, `@duration`, `@difficulty_level` and `@equipment`). The user is then prompted to select existing exercise movements to add to their routine from the list provided. To create this list, I call `#all` on the `Movement` class to return an array of all movement instances. I iterate through the array of movement instances, and for each movement instance, I generate a checkbox `<input>`. The name displayed beside each checkbox on the webpage is the text within the opening and closing checkbox `<input></input>` tags, the `@name` attribute value of each movement instance. The value property of the checkbox `<input>` equals the `@id` attribute value of each movement instance, so the `@id` value is sent through to the params hash to identify which existing exercise(s) were chosen when the form to create the routine is submitted. Consequently, when the form to create a new workout routine is submitted, the `params` hash has a top-level "routine" key, which points to (and stores) the routine hash containing information about the routine being created. The routine hash, nested inside of the `params` hash, looks something like this:
`{"name" => "@name value", "training_type" => "@training_type value", "duration" => "@duration value", "difficulty_level" => "@difficulty_level value", "equipment" => "@equipment value", "movement_ids" => [array of @id values of existing movement instances selected for use in the new routine]}`. The routine hash keys of `"name"`, `"training_type"`, `"duration"`, `"difficulty_level"` and `"equipment"` are the names of attributes of a routine instance, and the corresponding values, entered by the user in the form fields, become attribute values of a new routine instance, if the data is valid and a new routine is created. As seen above, the routine hash also has a `"movement_ids"` key, which points to (and stores) the array of `@id` attribute values of existing movement instances, which the user selected from the checkboxes provided, to include in the routine. In the form to create a new routine, the user can also optionally create a new movement to incorporate into the workout. Thus, when the form is submitted, the resulting `params` hash has a top-level key of `"movement"` which points to (and stores) the movement hash containing information about a new movement to add to the new routine. The movement hash, nested inside the `params` hash, has keys of `"name"`, `"instructions"`, `"target_area"`, `"reps"`, `"sets"` `"modification"` and `"challenge"`, named after the attributes of a movement instance. The corresponding hash values, i.e., whatever the user entered into these form fields, become attribute values of a new movement instance, if the data is valid and a movement is created as part of the new routine.

The second part of my create action, the `post '/routines'` route, receives data submitted in the form to create a new workout. The first `if` statement of my conditional logic, which reads `if params[:routine].values.any? {|value| value.empty?}`, checks to see if the user left any required fields pertaining to routine attributes blank, i.e., the values are empty strings. `params[:routine]` is the routine hash nested inside of the `params` hash. Calling `#values` on the routine hash returns an array of hash values, which include the values the user entered in the form fields for the routine’s name, training type, duration, difficulty level and equipment. I iterate over this array using `#any?`, which returns `true` if any array element makes the block evaluate to true. Therefore, if it is true that any form field was left blank (the value is an empty string), the user should be barred from creating a new routine since a routine instance cannot be saved to the database unless all of its attributes are assigned, due to ActiveRecord validations. Accordingly, the user receives a flash message reminding them to fill in all required routine fields when redirected to localhost:9393/routines/new, where the form is presented to try creating a new routine again. 

By contrast, if the user filled out all required routine fields, we must check whether or not the user simultaneously created a new exercise movement to be included in the workout. The line of code `if params[:movement].values.all? {|value| value.empty?}` returns `true` if the user did not create a new movement for the routine, since all form fields for a new movement's attributes were left blank. `params[:movement]` is the movement hash nested inside of the `params` hash. Calling `#values` on the movement hash returns an array of hash values, which are the values the user entered in the form fields for the movement's name, instructions, target area, reps, sets, modification and challenge attributes. If it is true that all values are empty strings, the user did not try to create a new movement for the new workout being created. We then call `#current_user` helper method to return the user instance currently logged in. Calling `#routines` on this user instance returns the array of routine instances belonging to the user instance. We call the ActiveRecord `#create` method on this collection of the user's routines, passing in the routine hash (`params[:routine]`) to instantiate a new routine instance with its attributes set via mass assignment and immediately belonging to the logged-in user instance. In the line of code `@routine.movement_ids = params[:routine][:movement_ids]`, we tell the routine instance which of the existing movement instances were chosen to be part of the routine, since `params[:routine][:movement_ids]` is the array of `@id` values of existing movement instances that the user selected from the available checkboxes.The user is then redirected to the show page that displays the workout routine just designed, without having created a new exercise movement for it; the user sees a flash message confirming the routine's successful creation. 

If all form fields to create a new movement for the new routine are filled in, as is expressed in the line of code `elsif params[:movement].values.all? {|value| value != “”}`, then a valid movement can be created with all of its attributes assigned. As in the previous scenario, we first create and save to the database the routine instance with its attributes set via mass assignment and immediately belonging to the user instance who's currently logged in, and then we tell the routine instance which of the existing movement instances, selected from the checkboxes, are used in the workout. The valid movement instance, stored in `new_movement` local variable, is then created. Calling `#movements` on the routine instance returns the array of movement instances used in the routine. Then, calling `#create` on this collection of the routine's exercises, passing in the movement hash argument, instantiates and saves to the database a movement instance with its attributes set via mass assignment and immediately associated with the routine instance, i.e., automatically incorporated into the workout. We could theoretically call `new_movement.routines` to return the array of routine instances in which this specific movement instance is performed, and inversely, we could call `#movements` on the routine instance that `new_movement` was automatically associated with when created, to return the array of movement instances, including `new_movement`, that are performed in that specific routine. 

In the line `new_movement.user = @routine.user`, we call the `#user=` method, provided by the ActiveRecord `belongs_to macro`, on the `new_movement` instance, to assign its `@user` property equal to the user instance who created it. In other words, we tell the `new_movement` instance that it belongs to the same user instance who created the `@routine` instance, whose array of movement instances the `new_movement` instance was built off of. Next, we call `#save` on this `new_movement` instance to ensure that its `user_id` foreign key column value is inserted into its row representation in the `movements` table. The user is then redirected to the webpage that displays the routine that was just generated, along with a flash message that confirms the creation of a new exercise movement for this routine.

The last clause of my conditional logic indicates that a new movement is considered invalid if the user only partially filled in the fields for the movement's required attributes. The user is redirected to localhost:9393/routines/new, where the form to create a new routine is again presented, and a flash message reminds the user that the completion of all form fields is mandatory, in order to successfully create a movement as part of the new workout.

**Read Action:**

A user is only permitted to view a workout routine if logged in; otherwise, the user is redirected to the page that displays the login form. If the user is logged in, the controller route `get '/routines/:slug'` renders the page that displays the specific workout routine requested, identified by the slugged version of the routine instance's `@name` attribute value, which replaces the `:slug` route variable in the URL. Since I extended my `RoutinesController` class with `Sluggable::ClassMethods` module, `#find_by_slugged_name(params[:slug])` can be called on the `Routine` class, where the argument `params[:slug]` is whatever value replaces the `:slug` route variable in the URL localhost:9393/routines/:slug. Within the method body of `#find_by_slugged_name(params[:slug])`, the `#generate_slug` method, defined within `Sluggable::InstanceMethods` module, is called. The method `#generate_slug` makes the `@name` attribute value of a routine instance all lowercase and replaces any spaces with hyphens. The method `#find_by_slugged_name(params[:slug])` returns the routine instance whose slugged `@name` attribute value, which results from calling `#generate_slug` on that instance, equals the value passed into the method as an argument. The view file, show_routine.erb, is then rendered.

Within the show_routine.erb view file, I use ERB substitution tags to interpolate the `@name` attribute value of the routine instance being displayed as the text of an `<h2>` header. Beneath it, I identify the user who created the specific routine being shown. Calling `#user` on the routine instance returns the user instance to which the routine belongs, and then calling the `#name` getter method on that user instance returns its `@name` attribute value, which is injected as the text of the `<h4>` subheader using ERB substitution tags. Further down on the page, I provide basic details about the workout, namely, the routine instance's `@training_type`, `@duration`, `@difficulty_level` and `@equipment` attribute values, each displayed in its own `<p>` element. Each attribute value is retrieved by calling the respective instance reader method on the routine instance and injected into the text of the paragraph using ERB substitution tags. The exercise movements that constitute the workout are enumerated in an unordered list. Calling `#movements` on the routine instance returns the array of movement instances that the routine consists of. I iterate through this array of movement instances, and for each movement instance included in the routine, I create a list item. Each list item has three main components. First, the each list item contains a link to the show page that displays the specific movement, where the clickable text of each link is the `@name` attribute value of the movement instance. Beside the name of the movement, the user is told how many sets of how many reps should be performed. The `@sets` and `@reps` attribute values of each movement instance are retrieved by calling the `#sets` and `#reps` getter methods on the routine instance, respectively, and injecting these values into the list item using ERB substitution tags.

The show page to display a single workout contains a link to the webpage that presents a form to edit the routine, as well as a delete button to remove the routine. In the `href` attribute value of the `<a>` link to the edit webpage, we retrieve the `@id` attribute value of the routine instance wished to be edited, using the `#id` getter method, and inject this value into the URL using ERB substitution tags.

When attempting to navigate to the page where a particular routine is edited, the user submits a GET request in the route `get '/routines/:id/edit'`. First we find the routine instance that the user wishes to edit by its `@id` attribute value, which equals `params[:id]`, the value that replaces the `:id` route variable in the URL. The `@routine` variable stores the routine instance that the user wishes to edit, to be used in the following conditional logic. If the user is not logged in, they are prevented from viewing the edit form and are instead redirected to the login page. If a user who is logged in tries to access the edit form of a workout routine that does not belong to them, the logged-in user is redirected to the index page of all routines, where a flash message informs them that they are not authorized to edit a routine designed by a different user. In the `elsif` clause, we call `#current_user` to return the user instance who's currently logged in, and then calling `#routines` on this user instance returns the array of routine instances belonging to the logged-in user. If the routine instance requested to edit belongs to the user instance who's currently logged in, i.e., the routine instance is included in logged-in user instance's array of routine instances, the edit_routine.erb view file is rendered.

The edit_routine.erb view file presents the actual form to edit the routine. This form is very similar to the one used to create a new workout, except for a few differences. To begin, the `<h2>` header at the top of the view file reads "Edit Workout Routine" instead of "Create Workout Routine." Whereas the `post "/routines"` route of the `RoutinesController` receives data submitted in the create form, the `patch "/routines/:slug"` route receives the data submitted in the edit form. Accordingly, the form to edit a routine contains a hidden `<input>` to change the method used to submit the form from a POST request to a PATCH request. The fields to edit a routine's Name, Training Type, Duration, Difficulty Level and Equipment are already filled in with the attribute values previously assigned, by setting the value property of each `<input>` field equal to the routine instance's corresponding attribute value, which is retrieved by calling the appropriate getter method on the routine instance and injecting that return value using ERB substitution tags. In the edit form, the checkboxes of existing exercises that were previously added to the routine are marked by adding 'checked' to each checkbox’s opening `<input>` tag, if the movement instance in question is included in the routine instance's array of movement instances composing the workout. The fields to create a new movement to include in the workout are the same as those in the create form, but the text of the submit button on the edit form reads "Edit Routine," as opposed to "Create Routine," which is the text on the create form's submit button.

**Update Action:**

The route `patch '/routines/:slug'` receives the data submitted in the form to edit a specific workout routine. Within this controller action, we find the routine instance that the user wants to edit by the slugged version of its `@name` attribute value, which replaces the `:slug` route variable. In the first clause of the conditional logic, `if params[:routine].values.any? {|value| value.empty?}`,we check to see if any of the fields for the routine instance's required attributes are left blank. The edit form uses the same nested hash structure as the create form, so once again, `params[:routine]` is the routine hash nested inside of the `params` hash. Calling `#values` on this routine hash returns an array of hash values, i.e., an array containing prospective values for the `@name`, `@training_type`, `@duration`, `@difficulty_level` and `@equipment` attributes of the routine instance being edited, as well as the `movement_ids` array of `@id` values of existing movement instances used in the routine. The iterator `#any?` returns `true` if any array element makes the block evaluate to `true`, so if any value is an empty string, the user is redirected to the page that presents the edit form again, where a flash message is displayed to remind them to fill in all five fields for the routine's required attributes. 
If all fields pertaining to routine attributes are filled in, I use embedded conditional logic to check if a user created a new, valid movement to add to their routine. If the statement that reads `if params[:movement].values.all? {|value| value.empty?}` evaluates to `true`, this means that the user did not create a new movement to add to the workout. `params[:movement]` is the movement hash nested inside of the `params` hash. Calling `#values` on the movement hash returns an array of hash values which are prospective attribute values for a new movement instance; if all values are empty strings, this means that all form fields for creating a new movement were left blank. In this case, I simply update the existing movement instances used in the routine instance. When the edit form was submitted, the `@id` values of the movement instances whose checkboxes were selected passed through to the `params` hash. Thus, I can call `#movement_ids` on the routine instance to set its `@movement_ids` property equal to the array of `@id` values of movement instances selected from the checkboxes, to incorporate these movements into the routine. I then call `#update` on the routine instance, passing in the nested routine hash, to update and save the attribute values of the routine instance via mass assignment, since some values might have been changed in the edit form. The user is then redirected to the webpage that displays the routine they just edited, without having created a new movement for it. The URL for a routine's show page is created by using string interpolation and calling `#generate_slug` on the routine instance to return the slugged version of its `@name` attribute value to add to the URL. Additionally, the show page will display a flash message to confirm that the workout routine was successfully updated.

The line of code `params[:movement].values.all? {|value| value != ""}` will evaluate to `true` if all form fields to create a new movement for the routine were filled in, i.e., no value is an empty string. Due to ActiveRecord validations in the `Movement` model, a movement instance must be assigned values for all of its attributes in order to be successfully saved to the database, so a valid movement can therefore be created in this case. As in the previous conditional clause, I update the existing movement instances that are used in the routine in the line of code `@routine.movement_ids = params[:routine][:movement_ids]`, and using mass assignment, I update and save to the database the routine instance's attribute values in the line of code `@routine.update(params[:routine])`. Next, I instantiate the new movement instance to be added to the workout routine that the user is editing. Calling `#movements` on the routine instance returns the array of movement instances that constitute the workout routine. Then calling `#create` on the routine's array of movement instances, and passing in the nested movement hash, creates and saves to the database a new movement instance with its attributes set via mass assignment and already incorporated into the routine that the user is editing. Since a movement instance belongs to the user instance who created it, I call the `#user=` method on the new movement instance, provided by ActiveRecord's `belongs_to` macro, to set the `@user` property of the new movement instance equal to the user instance who's currently logged in and editing the routine. I call `#save` on the new movement instance to ensure that its foreign key `user_id` value is saved to the database. The user is then redirected to the webpage that displays the edited routine, which now includes a new exercise movement; the flash message confirms that their workout routine was successfully updated. 
	Finally, if the user submitted an edit form in which all routine attributes were filled in, but only some of the fields to design a new movement for this routine were completed, the new movement will not be created; the data is invalid because a movement instance can only be saved to the database if all attribute values are assigned. Consequently, the user is redirected to the webpage that presents the routine edit form, and a flash message notifies the user that all fields must be filled out to create a new movement for the workout routine.
	
**Delete Action:**

On the show page that displays a single workout routine, the Delete Routine "button" is actually a form whose data is received by the `delete '/routines/:id/delete'` route upon submission. In the action property value of the `<form>` tag, which indicates where the form is sent, we retrieve the `@id` attribute value of the routine instance wished to be deleted, using the `#id` getter method, and inject this value into the URL using ERB substitution tags. The delete form also contains a hidden `<input>`, which changes the method of sending the form from a POST request to a DELETE request.

When the user clicks the Delete Routine button on the show page of the routine they wish to delete, the `delete '/routines/:id/delete'` route receives the data. If the user is not logged in, they are promptly redirected to the login page. However, if the user is logged in, we first find the routine instance wished to be deleted by its `@id` attribute value, which equals `params[:id]`, the value that replaces the `:id` route variable. In the line of code that reads 
`if current_user.routines.include?(@routine)`, we check to see if the routine instance wished to be deleted is included in the array of routine instances belonging to the logged-in user. If the routine belongs to the user, the routine instance is deleted by calling `#delete` on it; the user is redirected to the index of all routines, where a flash message confirms the deletion of the requested routine, and the user sees that the deleted routine has been omitted from the list. However, if the routine requested for deletion does not belong to the logged-in user, they are unable to delete it. Accordingly, the user is redirected to the index of all routines, where a message notifies them that that they are not authorized to delete a routine designed by a different user.
