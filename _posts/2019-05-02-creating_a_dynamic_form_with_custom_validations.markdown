---
layout: post
title:      "Creating a Dynamic Form with Custom Validations"
date:       2019-05-02 20:01:12 -0400
permalink:  creating_a_dynamic_form_with_custom_validations
---


In a recent React + Redux project, I created a form that has dynamically-generated inputs, which provides an easy, scalable and maintainable way to add more form fields, should the need arise in the future. In my project, React container class component `CakeCustomizerForm` renders a form that enables a pastry chef to provide additional details about the dessert she is designing. The local state object in `CakeCustomizerForm` has a key called `pastryParticulars`, which points to an object that contains top-level keys for each input identifier in the form. For example, `pastryParticulars` object has top-level keys for `occassion` (for the field where the user enters the occassion that calls for the cake), as well as `garnish` and `toppers` (for the dropdown menus for selecting different types of dessert decorations).  Each top-level key in `pastryParticulars` object points to an object that contains key/value pairs of data describing the configuration of the input corresponding to that property. This input configuration object has a key of `stringTag` that points to the string name of the form element that will be rendered, such as `'input'` or `'select'`. If the field being rendered is a textfield `<input>`, the `tagContents` key points to a nested object with key/value pairs for `type` and `placeholder` attributes of an `<input>`, but if the field being rendered is a `<select>` dropdown menu, `tagContents` points to a different type of nested object. This object has a key `optionsArray`, which points to an array of option objects, where each option object has key/value pairs for `value` and `label`, to configure each `<option>` in the dropdown menu. The `validationCriteria` key points to an object that contains key/value pairs describing validation rules for that particular input identifier, such as `cannotBeBlank: true` (if a value is required and the field cannot be empty) and `positiveNumberIsRequired` (if the user must enter a positive integer). The `value` key stores a string of the value typed into a textfield `<input>` or the value of the `<option>` selected in the dropdown menu. The `isValid` key is initially set to `false` by default, but it will reflect the result of a validation test and will be used to check if any field has invalidated the form. Finally, the `interactedWith` key is initially set equal to `false`. This key/value pair is important for determining when to check the form's validity. I only want to check the validity of the value entered in a form field if the user has interacted with that field; when an empty, untouched form is first rendered on the page, validation error styling should not be applied. 

If I want to add additional fields to this form in the future, I only need to make changes in one place: the form configuration object, which is stored in the local state of `CakeCustomizerForm`. Within the `render` method in `CakeCustomizerForm`, I dynamically generate the required form elements based on this `pastryParticulars` configuration object. To do so, I initially set the variable `cakeCustomizerConfiguration` equal to an empty array. I use `for…in` to iterate over the input identifier top-level keys in `pastryParticulars` object. For each `pastryProperty` top-level key (e.g. `customer`, `garnish`, `name`, or `message`), I create and push a new JavaScript object into `cakeCustomizerConfiguration` array that has a key/value pair for the `pastryProperty` input identifier and a key of `setup` that points to the object corresponding to this `pastryProperty` input identifier in `pastryParticulars` object). The variable `cakeCustomizerConfiguration` ultimately stores an array in which each element is a JavaScript object with a  key/value pair for the name of the `pastryProperty` (the input identifier, such as `garnish` or `flavor_combination`) and a `setup` key pointing to the object that represents the configuration of the HTML form element for that specific input identifier. Calling .`map()` on an array invokes the provided callback function once with each array element and returns an array of resulting values. I call `.map()` on the `cakeCustomizerConfiguration` array of JavaScript objects. For each object element in the  array, I render a `DynamicFormElement` child component and pass in the different parts of the input configuration as props. Therefore,	I am creating the fields for my form dynamically, and the array of these rendered `<DynamicForm />`components is injected inside the`<form></form>` opening and closing tags. 

To handle custom form validation, I created and imported a function called `meetsValidationCriteria`, and I ensured that the form submit button is disabled unless all form fields are valid. Arrow function `meetsValidationCriteria` accepts two arguments: the `currentValue` entered or selected in the form field and the `criteria` (i.e. rules for validation), which is either the `validationCriteria` object that looks like `{cannotBeBlank: true}` or `{positiveNumberIsRequired: true}`, which I got from the object corresponding to the input identifier key found in the `pastryParticulars` object in the local state object of `CakeCustomizerForm` . Within the body of `meetsValidationCriteria` function, I	first set `criteriaMet` equal to `true`. I do not set `criteriaMet`  equal to `false` initially because then I would be checking each validation rule successively, and even if one rule evaluated to false, if the very last rule evaluated to true, the whole function would return `true`. By initially setting `criteriaMet` to `true` and then conditionally reassigning its value depending on if the current validation test passes and `criteriaMet` was already true, I ensure that all fields have to evaluate to `true` for the function to return `true` (when `criteriaMet` is ultimately returned at the end of `meetsValidationCriteria` function). The first validation test is presented with the following conditional logic: `if (criteria.cannotBeBlank) { criteriaMet = currentValue.trim().length && criteriaMet }` Here, I am checking if the `validationCriteria`object has a key called `cannotBeBlank`. If this validation rule exists, the `if` statement does not evaluate to `falsy`, so I perform the following steps: Calling `.trim()` on the `currentValue` entered in the form field removes any leading and trailing whitespace. Then, calling `.length()` on the result will tell me if the form field is blank (a length of 0 is falsy in JavaScript), or if the user filled in the field  (the length of the value  is > 0). 
The `criteriaMet` variable will be reassigned to `true` if this current validation test is `true` (i.e. the field is not blank) and if the `criteriaMet` variable was already true. The second validation test is presented with the following `if` statement:
`if (criteria.positiveNumberIsRequired) { criteriaMet = /^[1-9]+$/.test(currentValue) && criteriaMet }`. Here, I check if the `validationCriteria` object has a key called `positiveNumberIsRequired`. If this validation rule exists, the `if` statement does not evaluate to a falsy value, so I use RegEx to specify that I'm searching for one or more of a single digit character in the range from 1 to 9. The JavaScript .`test()` method tests for a match in a string. The method returns `true` if it finds a match, or `false` otherwise. The variable `criteriaMet` will be reassigned to `true` if it’s true that the `currentValue` entered in the form is a positive number and if `criteriaMet` was already equal to `true`.




