---
layout: post
title:      "OCDefeat Rails Portfolio Project"
date:       2018-07-19 16:09:27 -0400
permalink:  ocdefeat_rails_portfolio_project
---

Pursuing my interest in psychology and programming, I designed a Rails application that allows patients and mental health professionals to collaborate in the development of Exposure and Response Prevention (ERP) plans, a therapy technique that is commonly used in the treatment of Obsessive Compulsive Disorder (OCD).

One of the challenges that I encountered while coding was figuring out how to slim down "fat" controllers, namely, cluttered `#index` actions that contained repetitive, branching conditional logic to handle filtering. The Query Object Design Pattern was an effective strategy to refactor my code. In Rails, a query object is a "Plain Old Ruby Object (PORO)," typically a class that enables you to write a large, complex, composite SQL query with ActiveRecord.

My filtering logic in `users#index` was a prime candidate for query object refactoring. On the users' index page, a therapist views data about her patients. I render `app/views/filter_users/_therapist.html.erb`, which presents a search form that allows the therapist to filter her patients by OCD severity, OCD variant, the theme that patients' obsessions revolve around, treatments they've undergone and the date that they recorded new obsessions in their Obsessions Log. Rather than defining multiple ActiveRecord class methods in my `User` model and employing method chaining to filter patients `.by_ocd_severity`, `.by_ocd_variant` and `.by_ocd_severity_and_variant`, I decided to delegate querying to a query object, which creates an amalgamation of these queries in one isolated place. That way, I could concisely call an instance method on my `PatientFinder` query object in `users#index`,  but under the hood of this seemingly simple and eloquently-named object, all of my complex filtering logic would be tucked away into a readable class which fulfills the single responsibility of filtering a therapist's patients.

To begin, I tried writing the code I wish I had. In `users#index`, the local variable `users` is set equal to `policy_scope(User)`, which is an ActiveRecord::Relation of the therapist’s patients when the `current_user` is a therapist. I assigned `@filtered_users` equal to the result of instantiating a soon-to-be-defined query object called `PatientFinder`, passing in the `users` argument (the ActiveRecord::Relation of the therapist’s patients, which is the default scope when no filters are applied on the users’ index page). I then called a soon-to-be-defined instance method, `#call(params)`, on the `PatientFinder` query instance, passing in `therapist_filters_patients_params`, which I defined as a private method in `UsersController` that returns the permitted filtering params data submitted in the search form. In short:
```@filtered_users = PatientFinder.new(users).call(therapist_filters_patients_params)```.

Following this blueprint of how I wanted my code to function, I set out to make my code actually work. I defined `class PatientFinder`, my query object, in `app/queries/patient_finder.rb`. Like many Rails query objects, `PatientFinder` accepts an ActiveRecord::Relation on instantiation, represented by `default_scope`in my `#initialize` method and `policy_scope(User)` in `users#index` before filtering is performed. In the case of `PatientFinder`, which is only used when a therapist views the users’ index page, `default_scope` is the ActiveRecord::Relation of the logged-in therapist's patients, i.e., an ActiveRecord::Relation of user instances with role`1` ("patient") whose `counselor_id` foreign key attribute equals the primary key `id` of the user instance with role `2`("therapist") who’s performing the filtering. Elsewhere in my application, I defined other query objects that are shared by patient and therapist filterers alike, in which `default_scope` differs depending on the filterer's role-based permissions. For example, query object `ObsessionFinder` is used in the contexts of a patient filtering her own obsessions and a therapist filtering her patients’ obsessions. The `default_scope` that is passed to an instance of `ObsessionFinder` when the obsessions' index is first presented is represented as `policy_scope(Obsession)` in `obsessions#index`. As previously mentioned, a patient views an index of solely her own obsessions due to patient privacy and confidentiality, so `policy_scope(Obsession)` is an ActiveRecord::Relation of that patient’s own obsessions. By contrast, a therapist views an index of all of her patients' obsessions, so `policy_scope(Obsession)`is an ActiveRecord::Relation of the therapist's patients' obsessions when the therapist views the obsessions' index page.

Writing the code I wish I had once more, I defined instance method `#call(params)` in `PatientFinder` class, which accepts the return value of `therapist_filters_patients_params` as its argument, i.e.,the data submitted in the search form to filter the therapist's patients. Within the method body of `#call(params)`, I call five instance methods that resemble class methods which could have been defined in my ActiveRecord `User` model. These five methods are called to represent any number and combination of filtering parameters that will shape the final `scoped` ActiveRecord::Relation of user instances ultimately returned by `#call(params)`. For example, the therapist can narrow her search extensively using the four filters `:severity`, `:variant`, `:treatment_undergone` and `:theme_fixation` to target only patients diagnosed with mild, traditional OCD  who have undergone talk therapy and obsess about contamination, or she can limit her search to two filters to find purely obsessional patients who ruminate about existential questions. The first argument of each instance method is the local variable `scoped`, which stores the *current* ActiveRecord::Relation of the therapist’s patients that was previously modified by the last filtering parameters applied and that we're continuing to manipulate with filters. Within the method body of `#call(params)`, we call each instance method to check if each filter was applied, so we can modify the collection of patients accordingly. If the second argument in an instance method is a blank value, this indicates that the filter was not applied and the `scope` that was passed into the instance method as the first argument is returned and passed into the next instance method as an argument. If users who match *all* search criteria are found, `scope` is reassigned to store this modified collection, which becomes the `scope` argument passed into the subsequent instance method called inside the method body of `#call(params)`. However, if no user instances match all filters applied, an empty ActiveRecord::Relation is returned.

A concrete example should help us visualize this. Let's say that the therapist clicks on the users' index page to view their patients and initially decides to filter patients by OCD severity. Since OCD severity is the first filter selected, the `scoped` argument of `#filter_by_severity(scoped, severity)` is the `default scope`, i.e., the ActiveRecord::Relation containing all of the therapist’s patients. The `severity` argument is the value of `params[:severity]`, which is the string severity `"Mild"`, `"Moderate"`, `"Severe"` or `"Extreme"`, i.e., whatever value the user selected in the OCD Severity dropdown menu in the search form. As seen in the method body of `#filter_by_severity(scoped, severity)` in `PatientFinder` class, since `params[:severity]` is *not* a blank value when the therapist selects a value from the dropdown menu, the `else` clause of `#filter_by_severity(scoped, severity)`returns `scoped.where("severity = ?", severity)`, i.e., an ActiveRecord::Relation of user instances whose `severity` attribute value equals whatever value the therapist chose in the dropdown menu (or an empty ActiveRecord::Relation if no users with the specified OCD severity are found).  Assuming that users with the specified severity *are* found, if OCD severity is the *only* search parameter that the therapist applies to filter her patients, `@filtered_users` (defined in `users#index`) will store this ActiveRecord::Relation of the therapist’s patients who have the specified OCD severity attribute value. However, let's say that the therapist wants to apply another filter and find all of her patients who are *not only* diagnosed with a particular OCD severity (`"Moderate"`) *but also* a particular OCD variant (`"Purely Obsessional"`.) In the method body of `#call(params)`, the local variable `scoped` is continuously re-assigned to reflect an increasingly narrowed search, i.e., the application of more search criteria to filter the therapist's patients. If the therapist found her patients who have moderate OCD first, `scoped` (returned by calling `#filter_by_severity(scoped, severity)` stores an ActiveRecord::Relation of user instances whose severity attribute value = `"Moderate"`. To find patients who have moderate, traditional OCD, the ActiveRecord::Relation of users whose `severity` attribute value = `"Moderate"` is passed into `#filter_by_variant(scoped, params[:variant])` as the first argument. The second argument, `params[:variant]`, is whatever string value the user selected from the OCD Variant dropdown menu in the search form. In this case, we select `"Purely Obsessional"` from the three available variant options: `"Traditional"`,` "Purely Obsessional"` and `"Both"`. This means that, from the collection of users whose `severity` attribute value = `"Moderate"`, we are further specifying that we want to retrieve users whose variant attribute value = `"Purely Obsessional"`. An empty ActiveRecord::Relation is returned if there are no user instances whose `severity` attribute = `"Moderate"` *and* whose `variant` attribute = `"Purely Obsessional"`.  Otherwise, the local variable `scoped` that stores the result of calling `#filter_by_variant(scoped, variant)` after having called `#filter_by_severity(scoped, severity)` is reassigned to store this ActiveRecord::Relation of users whose `severity` attribute value = `"Moderate"` *and* whose `variant` attribute value = `"Purely Obsessional"`. This collection is then passed in as the first argument of the *next* filtering method called: `#filter_by_fixation(scoped, theme_fixation)`. If the therapist did *not* filter her patients by those who have at least one obsession that pertains to a particular OCD theme, the second argument of this method, `params[:theme_fixation]`, is a blank value when the search form is submitted. Therefore, `scoped`, the *same* ActiveRecord::Relation of users whose `severity` attribute value = `"Moderate"` *and* whose `variant` attribute value = `"Purely Obsessional"` is returned by `#filter_by_fixation(scoped, theme_fixation)` and is passed in as the first argument of the *next* instance method called in the method body of `#call(params)`, which is `#filter_by_treatment(scoped, treatment_undergone)`.

However, if the therapist *does* search for patients who exhibit a specific combination of OCD severity, variant *and* theme fixation—let's say, patients who suffer from Mild, Purely Obsessional OCD who *also* recorded at least one obsession that revolves around the theme `"Contamination"`— `params[:theme_fixation]` stores the primary key `id` attribute value of the theme instance that was selected by its `name` attribute `"Contamination"` from the OCD Theme Fixation dropdown menu in the search form. This triggers the `else` clause logic in `#filter_by_fixation(scoped, theme_fixation)`: 
`scoped.joins(obsessions: :theme).where(themes: { id: theme_fixation })`. Here, `scoped` stores the ActiveRecord::Relation of user instances who have `severity` attribute value = `"Moderate"` *and* `variant` attribute value = `"Purely Obsessional"`. As seen in the `joins` statement, a patient user instance `has_many`obsessions, and each obsession `belongs_to` one overarching theme that supplies content for that obsession. In the `where` clause, we target those patients belonging to the therapist who have Moderate, Purely Obsessional OCD *and* who *also* recorded at least one obsession that `belongs_to` the theme that the therapist selected from the dropdown menu (the `theme_id` foreign key value of at least one obsession belonging to the patient should equal the primary key `id` of the theme instance selected in the dropdown menu – the value of `params[:theme_fixation]` submitted in the form). Finally, we call `distinct` to remove any duplicate users, which may be returned due to the `has_many :obsessions` association. In `#call(params)`, `scoped` is reassigned to this ActiveRecord::Relation of the therapist's patient user instances who have `severity` = `"Mild"`, `variant` = `"Purely Obsessional"` *and* at least one obsession that revolves around the theme `"Contamination"` (whose `id` is`3`). This `scoped` collection is then passed in as the first argument of the subsequent method `#filter_by_treatment(scoped, treatment_undergone)`. 

…And so on and so forth! With each successive filter applied, the value of `scoped` is reset to store the ActiveRecord::Relation of the therapist's patients who meet all search criteria submitted in the form, or an empty ActiveRecord::Relation if none is found, until the final `scoped` collection is returned at the end of `#call(params)`.
