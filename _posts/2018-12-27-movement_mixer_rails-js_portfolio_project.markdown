---
layout: post
title:      "Movement Mixer Rails-JS Portfolio Project"
date:       2018-12-27 18:53:14 -0500
permalink:  movement_mixer_rails-js_portfolio_project
---


For my Rails with JavaScript portfolio project, I developed an application called Movement Mixer that allows clients and their personal trainers to design workout routines together. I implement Pundit policies that authorize clients to create workout routines and trainers to edit their clients' routines. Additionally, trainers can create training guides to demonstrate how to properly perform exercise movements. As such, a client (user whose `role` = 1) `has_many :routines`, and a trainer (user whose `role` = 2) `has_many :guides`.

To fulfill the project requirement of rendering an index resource via JavaScript and an Active Model Serialization JSON backend, I render an index of workout routines that belong to a client on that client's show page. A client's show page contains a link with a class of `.load-user-routines` to preview that client's workout routines, if any exist. (If the client did **not** design any workout routines, i.e., the collection is empty, the link is **not** displayed). Similarly, a trainer's show page contains a link with a class of `.load-user-guides` if that trainer created any guides, and upon clicking this link, I render an index of training guides belonging to that trainer. To abstract away repetitive JavaScript click event listeners, I refactored my code by defining a single arrow function called `loadBelongsToDeclarer`, which loads objects of the model (`Routine` or `Guide`) that declares the `belongs_to :user` association. This arrow function hijacks the click event of either `a.load-user-routines` or `a.load-user-guides`, to retrieve routines or guides that belong to the user, respectively. In `loadBelongsToDeclarer` arrow function, I call `.on()` method on the jQuery object of the link whose class begins with `'load-user'`, which I select using jQuery selector `$('a[class^=load-user]')`. The method `.on()` accepts the name of the `'click'` event as its first argument and a callback function to handle the click event hijacking as its second argument. I prevent the default behavior of clicking the link, which would be a normal HTTP GET request to `'/users/:id'`, which is the `href` attribute value of this `<a>` link.

I am able to retrieve the routines or guides that belong to the user by making an AJAX GET request to `'/users/:id.json'` because I include the macros `has_many :routines` and `has_many :guides` in my `UserSerializer` class. This ensures that a successful JSON response **not only** includes the JSON object representation of the user instance whose routines/guides I want to view, but **also** includes the very array of routine/guide objects belonging to the user nested within it.

In `loadBelongsToDeclarer` arrow function, I then set the `id` variable equal to the value of the clicked link's `data-id` attribute, which stores the `id` of the user whose workout routines or training guides I want to retrieve. Using `let`, I store `User.loadUserRoutines` in the variable `loadAssociatedObjectsFunction`, and I can conditionally reassign the value of this variable in the `if` statement clause. I can determine if the user is trying to retrieve routines or guides by introspecting on the `class` attribute of the clicked link, which is either `'load-user-routines'` or `'load-user-guides'`. Splitting either string at a hyphen bordered by whitespace on both sides will yield the array `["load", "user", "routines"]` or `["load", "user", "guides"]`, and calling `.pop()` on this array will return the last element (the string `"routines"` or `"guides"`). If the string `"guides"` is returned, I know that the current user is trying to view the index of training guides belonging to a trainer, so I reassign the value of the variable `loadAssociatedObjectsFunction` to store `User.loadUserGuides`. Once it's been clicked, its `data-id` attribute value is stored and I've determined whether to retrieve routines or guides using its `class` attribute, I `$.hide()` the link. Using `$.get()` method, I send an AJAX GET request to `/users/${id}.json`. To format this URL, I use template strings, interpolate the value of the `id` variable, and I add the `'.json'` extension to indicate that I want to get a JSON response back instead of redirecting to `"/users/:id"`, reloading the page and redrawing the DOM. This route maps to the `#show` action in `UsersController` class. In `users#show`, I render a JSON object representation of the `@user` ActiveRecord instance, where each routine object in the user's array of routine objects **also** contains data about that routine's equipment requirements, workout target areas and fitness training types, and each guide object in the user's array of guide objects **also** contains data about the exercise movement for which the training tips were provided.

Sending an AJAX GET request using `$.get('/users/:id.json')` returns a `jqXHR` object, and I handle a successful JSON response I get back by calling `.done(loadAssociatedObjectsFunction)`.

To illustrate the way in which objects are rendered in JSON format and appended to the page, let's say that I want to load a client's workout routines on that client's show page. In this case, `loadAssociatedObjectsFunction` stores `User.loadUserRoutines`. `User.loadUserRoutines` points to a function that accepts the `userObject` parameter. This `userObject` parameter is a JSON object representation of the ActiveRecord user instance whose routines I want to view, i.e., it's a successful JSON response I get back from the AJAX GET request sent using `$.get()` method in `loadBelongsToDeclarer()`. In the variable declaration `let newUser = new User(userObject)`, a new user object is created by passing `userObject` to `User` constructor function. I declare `newUser` variable using `let` because this variable is used throughout my application and points to different user objects. I then select `div#belongs-to-user`, which is always present in `app/views/users/show.html.erb` view file, because I want to display the routines that belong to the client inside of this container. I declare `$userRoutinesDiv` variable using `const` because it is immutable. `$userRoutinesDiv` variable is only used once in my application and always points to the same jQuery object of `$('div#belongs-to-user'`), even though the contents stored inside this `<div>`  change as routines are appended to it inside of the iteration. The value corresponding to the `'routines'` key of `newUser` object is an array of routine objects (representing the `ActiveRecord::Relation` of routine instances belonging to the `@user` instance). I use Handlebars.js to format these routines for display inside of `$userRoutinesDiv`.

The Handlebars template for formatting the preview of each routine is found inside `script#routine-template`, which is found in `app/views/shared/_hs_templates.html.erb` partial. As seen in `Routine.compileRoutineTemplate` in `routines.js` file, `Routine.routineTemplateSource` stores the string HTML Handlebars template inside `script#routine-template`: `Routine.routineTemplateSource = $('#routine-template').html()`. Using Handlebars, I compile this HTML template source code, along with variables found inside the Handlebars delimiters `{{}}`, as part of a function that can be invoked with a context object: `Routine.routineTemplateFunction = Handlebars.compile(Routine.routineTemplateSource)`. Back in `User.loadUserRoutines`, using `.forEach()`, I iterate through the array of routine objects belonging to the user, and for each routine object (which is referenced as `routineObject` inside of the iteration), I define a new routine object: `let newRoutine = new Routine(routineObject)`. `Routine.routineTemplateFunction` is invoked with each `newRoutine` object as its context. Consequently, the values corresponding to the keys in each `newRoutine` object replace the variables with the same names that are found inside the Handlebars delimiters in the template. Each HTML template to display the routine, now containing values injected from each `newRoutine` object to be displayed, is appended to `$userRoutinesDiv`. The logged-in user is now able to preview all workout routines designed by a particular client on that client's show page.
