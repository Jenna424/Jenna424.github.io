---
layout: post
title:      "Code Confectionery: React-Redux Portfolio Project"
date:       2019-04-15 21:05:02 +0000
permalink:  code_confectionery_react-redux_portfolio_project
---

For my React-Redux portfolio project, I designed an application called Code Confectionery that enables pastry chefs to design custom cakes for a bakery menu and to propose ideas for new flavors. By completing this project, I gained a better understanding of the differences between stateful container class components and stateless presentational functional components in React, as well as the importance of updating state immutably. 

Container components hold state, or data that changes throughout the course of an application. In Code Confectionery, `CakeConstructor` is an example of a container class component. In `CakeConstructor.js` file, I connected my `CakeConstructor` component to the Redux store by using the `connect()` function imported from the react-redux library. In this file, the `mapStateToProps` function accepts the entire Redux store state as its argument and implicitly returns an object containing the portion of the Redux store state that I wish to update. This is ultimately used to determine which React components, if any, should be re-rendered, depending on whether or not state changes occurred when actions were dispatched in response to user interactions, such as clicking buttons to stack or unstack layers from the graphical representation of the cake. The slices of state found in the object returned by `mapStateToProps` are: `layers` (the array of layer objects fetched from my Rails server, which represents all flavors that are available for cake customization), `cakeLayout` (the array of layer objects that represents the structure of the cake that is currently being created), and `cakeCost` (the price of the cake, which changes as each layer is stacked or unstacked from the cakeâ€™s graphical representation, and which depends on the `'batter'` or `'filling'` pastry part that the layer represents). 

Since I designed `CakeConstructor` as a container class component, I am also able to utilize `componentDidMount` lifecycle method. In this method, I retrieve all available flavors for cake layers by calling `this.props.loadLayers()`, which is an action-dispatching function that I get from `mapDispatchToProps` function. The `mapDispatchToProps` function accepts the `dispatch` function as its argument and returns an object in which `loadLayers` key is the name of an action-dispatching arrow function. When the `CakeConstructor` component is rendered upon initially loading the root page of my application, `loadLayers()` is executed to send a `fetch()` request to retrieve all layers from my Rails API backend. Action-dispatching arrow function `loadLayers()` accomplishes this by calling the `dispatch()` function, in order to call the function returned by `loadLayers` asynchronous action creator function. The `loadLayers` asynchronous action creator function, made possible by `redux-thunk`, returns a function that accepts the `dispatch` function as its argument and makes a `.fetch()` request to my Rails API endpoint `'/layers'`. Having made this async call to fetch layers from my Rails API backend server, I handle the promise that is returned by calling `.then()` and converting the response to JSON in the arrow function.  This returns another promise, which I resolve by calling `.then()` again. If I get a successful JSON response back from my Rails server, the arrow function passed to `.then()` receives the array of layer objects as its argument. In the function body, I then call the `dispatch()` function to dispatch the action object that is returned by calling synchronous action creator function, `setLayersSuccess`. The synchronous action creator function, `setLayersSuccess`, accepts this array of layer objects as its argument and implicitly returns an action object of type `'SET_LAYERS_SUCCESS'` that contains the `layers` array as its payload. When this dispatched action object is intercepted by the `layerLeveler` reducer, hitting its corresponding case statement for `'SET_LAYERS_SUCCESS'` action type, I update the Redux store state with the new layers that I retrieved. In order to maintain immutability, I return a new, updated state object in the `switch`/`case` statement of `layerLeveler` reducer. Inside of this new state object, I first use the spread operator to copy over all key/value pairs from my previous, existing state object. I overwrite the `layers` key to point to a new array, using the spread operator to copy over all layer object elements found in the `layers` array, which is the value corresponding to the `layers` key in my action object, i.e., the payload of layer objects that I got back in the JSON response from the server. Within the new, updated state object, I also set the `error` key to the value `false` to clear it, just in case I previously got an error that has since been resolved. However, if my request to fetch layers from my Rails server failed, I set my `error` key to `true` in the Redux store state, so that I can use conditional logic to display an error message in my component. To this end, inside of `.loadLayers()`, I call `.catch()` and pass in an arrow function that accepts the error object as its argument. I dispatch the action object that is returned by calling synchronous action creator function `fetchLayersFailure()`. This function implicitly returns an action object of type `'FETCH_LAYERS_FAILURE'`, and when this action is dispatched and hits its corresponding case statement in the `layerLeveler` reducer, I return a new, updated state object in which I copy over all key/value pairs from the previous state object and then overwrite the value of the `error` key to set it equal to `true`.

As opposed to container components, presentational components are mainly concerned with display, or how components look when rendered on the page. Presentational components are often stateless functional components that simply accept props (which are passed down from parent container components) and return valid JSX code. `CakeMenuItem`, which is rendered from `CakesMenu` container component,  is an example of a presentational component in my application. Parent `CakesMenu` is defined as a container class component so that I can utilize the `componentDidMount()` lifecycle method to send a `fetch()` request to load all cake objects stored in my Rails API backend. If I successfully retrieve an array of cake objects from my server, I iterate through this array using `.map()` and render a `CakeMenuItem` presentational component for each cake object. `CakeMenuItem` is written as a functional component that accepts destructured props for the cake's `name`, `flavorCombination` and `price`, data that was passed down from parent `CakesMenu` component. When rendered, each `CakeMenuItem` component simply returns a `<div>` that contains a heading with the name of the cake, a paragraph describing the flavor combinations that the cake contains, a `<small>` tag with the price of the cake fixed to two decimal places, and a `<hr>` to create a visual separation between each cake listed on the menu.
